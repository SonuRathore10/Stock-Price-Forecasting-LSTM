# -*- coding: utf-8 -*-
"""lstm_model.keras.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_y0wwykcvDnE7FjkbbSFILrsm5w_UNTh

# üìà Stock Price Prediction using LSTM (Yahoo Finance Data)

This notebook implements a deep learning model using Long Short-Term Memory (LSTM) networks in TensorFlow/Keras to predict stock closing prices based on historical data from **Yahoo Finance**.

### üîç Overview:
- Retrieves and processes stock data from Yahoo Finance.
- Normalizes closing prices using MinMaxScaler.
- Generates time series sequences using a 100-day sliding window.
- Builds and trains a stacked LSTM model with dropout layers for regularization.
- Evaluates the model using RMSE (Root Mean Squared Error) on both train and test sets.
- Visualizes predicted vs. actual stock prices for performance insights.
- Saves the trained model for future use in `.keras` format.

This model is ideal for time series forecasting and can be integrated into financial analytics or trading tools.

---
"""

# Loading Libraries
import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Fetching Tesla Data
ticker_symbol = yf.Ticker("TSLA")
tesla_data = ticker_symbol.history(period="10y", auto_adjust=False)
print(tesla_data)

# Resetting the index to make 'Date' a column instead of the index
tesla_data.reset_index(inplace=True)

# Converting the 'Date' column to just the date part (no time component)
tesla_data['Date'] = pd.to_datetime(tesla_data['Date']).dt.date

# Displaying the cleaned DataFrame
tesla_data

# Relavant Columns for Analysis
tesla_selected = ['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']
tesla_selected = tesla_data[tesla_selected]
print(tesla_selected.head())

"""# Exploratory Data Analysis"""

# Data Information
print("Tesla DataFrame Info")
print("-" * 40)
print(tesla_selected.info())

# Summary Stats
print("\n Tesla Data Description (Summary Stats)")
print("-" * 40)
print(tesla_selected.describe())

# Data Shape
print("\n Shape of Tesla DataFrame")
print("-" * 40)
print(tesla_selected.shape)

# Null Values
print("\n Null Values in Each Column")
print("-" * 40)
print(tesla_selected.isnull().sum())

# Duplicated Rows
print("\n Number of Duplicated Rows")
print("-" * 40)
print(tesla_selected.duplicated().sum())

"""# Data Analysis

Trend Analysis
"""

tesla_selected['Date'] = pd.to_datetime(tesla_selected['Date'])
tesla_selected.set_index('Date', inplace=True)

# For better visuals
sns.set_style("whitegrid")

# Trend Analysis
plt.figure(figsize=(14,6))
plt.plot(tesla_selected.index,tesla_selected['Close'], color ='blue', linewidth=2)

plt.title("Tesla Stock Closing Price Trend (Last 10 Years)", fontsize = 16)
plt.xlabel("Date", fontsize=12)
plt.ylabel("Closing Price", fontsize = 12)
plt.tight_layout()
plt.show()

"""Moving Averages"""

# Calculate the Moving Averages
tesla_selected = tesla_selected.copy()
tesla_selected['SMA_20'] = tesla_selected['Close'].rolling(window=20).mean()

plt.figure(figsize=(16, 7))

# Closing Price
plt.plot(tesla_selected.index, tesla_selected['Close'], label = 'Closing Price', color = 'blue', linewidth = 1)
# Moving Averages
plt.plot(tesla_selected.index, tesla_selected['SMA_20'], label = '20-Day SMA', color = 'orange', linewidth = 2)
# Plotting Graph
plt.title("Tesla Stock: 20-Day Moving Average", fontsize = 16)
plt.xlabel("Date", fontsize = 12)
plt.ylabel("Price", fontsize = 12)
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.legend()
plt.tight_layout()
plt.show()

# Calculate the Moving Averages
tesla_selected['SMA_50'] = tesla_selected['Close'].rolling(window=50).mean()

# Plotting Graph
plt.figure(figsize=(14, 6))
plt.plot(tesla_selected.index, tesla_selected['Close'], label='Closing Price', color='blue', linewidth=1)
plt.plot(tesla_selected.index, tesla_selected['SMA_50'], label='50-Day SMA', color='green', linewidth=2)

plt.title("Tesla Stock: 50-Day Moving Average", fontsize=16)
plt.xlabel("Date", fontsize=12)
plt.ylabel("Price (USD)", fontsize=12)
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.legend()
plt.tight_layout()
plt.show()

# Calculate the Moving Averages
tesla_selected['SMA_100'] = tesla_selected['Close'].rolling(window=100).mean()

# Plotting the Graph
plt.figure(figsize=(14, 6))
plt.plot(tesla_selected.index, tesla_selected['Close'], label='Closing Price', color='blue', linewidth=1)
plt.plot(tesla_selected.index, tesla_selected['SMA_100'], label='100-Day SMA', color='red', linewidth=2)

plt.title("Tesla Stock: 100-Day Moving Average", fontsize=16)
plt.xlabel("Date", fontsize=12)
plt.ylabel("Price (USD)", fontsize=12)
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.legend()
plt.tight_layout()
plt.show()

"""Return Analysis"""

# DailyReturn
tesla_selected['Daily Return'] = tesla_selected['Close'].pct_change()
# Cumlative Return
tesla_selected['Cumulative Return'] = (1 + tesla_selected['Daily Return']).cumprod()

# Plot Daily Returns
plt.figure(figsize=(14,5))
plt.plot(tesla_selected.index, tesla_selected['Daily Return'], color='purple', linewidth = 0.8)
plt.title("Telsa Daily Return(%)")
plt.ylabel("Return")
plt.xlabel("Date")
plt.tight_layout()
plt.show()

# Plot Cumulative Return
plt.figure(figsize=(14, 5))
plt.plot(tesla_selected.index, tesla_selected['Cumulative Return'], color='darkgreen', linewidth=2)
plt.title("Tesla Cumulative Return (Normalized)")
plt.ylabel("Growth (Starting at 1)")
plt.xlabel("Date")
plt.tight_layout()
plt.show()

"""Volatility Analysis"""

# 30-Day Rolling Standard Deviation
tesla_selected['Rolling Volatility (30d)'] = tesla_selected['Daily Return'].rolling(window=30).std()

# Plot Volatility
plt.figure(figsize=(14, 5))
plt.plot(tesla_selected.index, tesla_selected['Rolling Volatility (30d)'], color = 'red', linewidth = 1.5)
plt.title("Tesla 30-Day Rolling Volatility")
plt.ylabel("Volatility")
plt.tight_layout()
plt.show()

# Volume Analysis
fig, ax1 = plt.subplots(figsize=(14, 5))
# Price Line
ax1.set_xlabel("Date")
ax1.set_ylabel("Closing Price", color= 'blue')
ax1.plot(tesla_selected.index,tesla_selected['Close'], color = 'blue', linewidth =1)
ax1.tick_params(axis='y', labelcolor = 'blue')

# Volume bars (Secondary Axis)
ax2 = ax1.twinx()
ax2.set_ylabel("Volume", color = 'grey')
ax2.bar(tesla_selected.index, tesla_selected['Volume'], color = 'red', alpha = 0.4)
ax2.tick_params(axis = 'y', labelcolor = 'gray')

plt.title("Tesla Stock Price vs. Trading Volume")
fig.tight_layout()
plt.show()

"""# LSTM Model"""

# Use just the 'Close' column
data = tesla_selected.filter(['Close'])
dataset = data.values  # Array

# Normalize between 0 and 1
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(dataset)

print(scaled_data)

scaled_data.shape

# Splitting dataset into train and test split
training_size = int(len(scaled_data)*0.65)
test_size = len(scaled_data)-training_size
train_data, test_data = scaled_data[0:training_size,:], scaled_data[training_size:len(scaled_data),:1]

len(train_data), len(test_data)

# Convert an array into dataset matrix
def create_dataset(training_dataset, time_step = 1):
  dataX, dataY = [], []
  for i in range(len(training_dataset)-time_step-1):
    a = training_dataset[i:(i+time_step),0]
    dataX.append(a)
    dataY.append(training_dataset[i+time_step,0])
  return np.array(dataX), np.array(dataY)

time_step = 100
X_train, y_train = create_dataset(train_data, time_step)
X_test, ytest = create_dataset(test_data, time_step)

print(X_train)

print(X_train.shape), print(y_train.shape)

print(X_test.shape), print(ytest.shape)

# Reshape input to be [samples, time steps, features] which is required for LSTM.
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

# Create LSTM Model
model = Sequential()
model.add(LSTM(50, return_sequences = True, input_shape = (100,1)))
model.add(Dropout(0.4))
model.add(LSTM(50, return_sequences = True ))
model.add(Dropout(0.4))
model.add(LSTM(50))
model.add(Dropout(0.4))
model.add(Dense(1))
model.compile(loss = 'mean_squared_error', optimizer = 'adam')

model.summary()

model.fit(X_train, y_train, validation_data = (X_test, ytest), epochs = 50, batch_size = 32, verbose = 1)

# Prediction & Performance Metrics
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Transformback to original form
train_predict = scaler.inverse_transform(train_predict)
test_predict = scaler.inverse_transform(test_predict)

# RMSE Performance Metrics
import math
from sklearn.metrics import mean_squared_error
math.sqrt(mean_squared_error(y_train, train_predict))

# Test data RMSE
math.sqrt(mean_squared_error(ytest, test_predict))

look_back = 100
# Train Predictions for Plotting
train_predict_plot = np.empty_like(scaled_data)
train_predict_plot[:, :] = np.nan
train_predict_plot[look_back:len(train_predict)+look_back, :] = train_predict
# Test Predictions for Plotting
test_predict_plot = np.empty_like(scaled_data)
test_predict_plot[:, :] = np.nan
test_predict_plot[len(train_predict)+(look_back*2)+1:len(scaled_data)-1, :] = test_predict
# Plot
plt.plot(scaler.inverse_transform(scaled_data))
plt.plot(train_predict_plot)
plt.plot(test_predict_plot)
plt.show()

len(test_data)

x_input = test_data[781:].reshape(1,-1)
x_input.shape

temp_input = list(x_input)
temp_input = temp_input[0].tolist()

temp_input

# demonstrate prediction for next 10 days
from numpy import array

lst_output=[]
n_steps=100
i=0
while(i<30):

    if(len(temp_input)>100):
        #print(temp_input)
        x_input=np.array(temp_input[1:])
        print("{} day input {}".format(i,x_input))
        x_input=x_input.reshape(1,-1)
        x_input = x_input.reshape((1, n_steps, 1))
        #print(x_input)
        yhat = model.predict(x_input, verbose=0)
        print("{} day output {}".format(i,yhat))
        temp_input.extend(yhat[0].tolist())
        temp_input=temp_input[1:]
        #print(temp_input)
        lst_output.extend(yhat.tolist())
        i=i+1
    else:
        x_input = x_input.reshape((1, n_steps,1))
        yhat = model.predict(x_input, verbose=0)
        print(yhat[0])
        temp_input.extend(yhat[0].tolist())
        print(len(temp_input))
        lst_output.extend(yhat.tolist())
        i=i+1


print(lst_output)

day_new=np.arange(1,101)
day_pred=np.arange(101,131)

len(scaled_data)

plt.plot(day_new,scaler.inverse_transform(scaled_data[2415:]))
plt.plot(day_pred,scaler.inverse_transform(lst_output))

df3=scaled_data.tolist()
df3.extend(lst_output)
plt.plot(df3[2000:])

# After training your model
model.save("lstm_model.keras")